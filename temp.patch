diff --git a/Makefile b/Makefile
index 02a62df..94371e5 100644
--- a/Makefile
+++ b/Makefile
@@ -219,6 +219,7 @@ UPROGS=\
 	_chmod\
 	_su\
 	_test\
+	_chdot\
 	_pwdtest\
 	
 
diff --git a/adduser.c b/adduser.c
index 3de694b..469f806 100644
--- a/adduser.c
+++ b/adduser.c
@@ -69,7 +69,7 @@ struct user* createUser(char username[]){
     char dir[100];
     strcpy(dir, "/home/");
     strcat(dir, username);
-    mkdir(dir);
+    // mkdir(dir);
 
     struct user* u = (struct user*) malloc(sizeof(struct user));
     strcpy(u->username, username);
@@ -288,6 +288,20 @@ void printUserArray(){
     // exit();
 }
 
+void create_dot_path(char *dir_path, char *dot_path) {
+    int i = 0;
+    while (dir_path[i] != '\0') {
+        dot_path[i] = dir_path[i];
+        i++;
+    }
+    dot_path[i] = '/';
+    i++;
+    dot_path[i] = '.';
+    i++;
+    dot_path[i] = '\0';
+}
+
+
 int main(int argc, char* argv[]){
 
     if (argc<2){
@@ -301,7 +315,8 @@ int main(int argc, char* argv[]){
     struct user* u = createUser(argv[1]);
 
     printf(1, "%s\n", u->homedir);
-    mkdir(u->homedir);
+    mkdir2(u->homedir, u->uid);
+    printf(1, "uid is: %d\n", u->uid);
 	addUserToPasswd(u);
     
     // printUserArray();
diff --git a/chdot.c b/chdot.c
new file mode 100644
index 0000000..833bb6d
--- /dev/null
+++ b/chdot.c
@@ -0,0 +1,24 @@
+  #include "types.h"
+#include "stat.h"
+#include "user.h"
+#include "fcntl.h"
+
+int
+main(int argc, char *argv[])
+{
+  if(argc != 3){
+    printf(2, "Usage: chdotuid <inode-number> <uid>\n");
+    exit();
+  }
+
+  int inum = atoi(argv[1]);
+  int uid = atoi(argv[2]);
+
+  if(chdotuid(inum, uid) < 0){
+    printf(2, "chdotuid failed\n");
+    exit();
+  }
+  printf(1, "done");
+  exit();
+}
+
diff --git a/exec.c b/exec.c
index 8001eb0..944d7b6 100644
--- a/exec.c
+++ b/exec.c
@@ -86,7 +86,7 @@ strcat(buf, path);
       goto bad;
   }
   iunlockput(ip);
-  curproc->exec_inode = idup(ip);
+  // curproc->exec_inode = idup(ip);
   end_op();
   ip = 0;
 
diff --git a/fs.c b/fs.c
index 3c64618..919cc59 100644
--- a/fs.c
+++ b/fs.c
@@ -696,3 +696,10 @@ nameiparent(char *path, char *name)
 {
   return namex(0, path, 1, name, 0, 1);
 } 
+
+struct inode*
+get_inode_by_num(uint dev, uint inum)
+{
+  return iget(dev, inum);
+}
+
diff --git a/fs.h b/fs.h
index dcca554..7ac19d7 100644
--- a/fs.h
+++ b/fs.h
@@ -59,3 +59,5 @@ struct dirent {
   char name[DIRSIZ];
 };
 
+struct inode* get_inode_by_num(uint dev, uint inum);
+
diff --git a/init.c b/init.c
index 9e76309..ae9a2b8 100644
--- a/init.c
+++ b/init.c
@@ -26,7 +26,7 @@ main(void)
   }
   dup(0);  // stdout
   dup(0);  // stderr
-  	mknod("/dev/null", 2, 1);
+  mknod("/dev/null", 2, 1);
 	mknod("/dev/zero", 3, 1);
 
   for(;;){
diff --git a/passwd b/passwd
index 71d8136..e2d2084 100644
--- a/passwd
+++ b/passwd
@@ -2,4 +2,5 @@ root:x:0:0:root:/root:/
 daemon:x:1:1:daemon:/usr/sbin:/
 bin:x:2:2:bin:/bin:/
 sys:x:3:3:sys:/dev:/
-a:a:1000:1000:aagamjain:/home/aagam
+aagam:aagam:1000:1000:aagamjain:/home/aagam
+b:b:1001:1001:aagamBakliwal:/home/bakliwal
diff --git a/syscall.c b/syscall.c
index 12b68cb..c8c4fb0 100644
--- a/syscall.c
+++ b/syscall.c
@@ -123,6 +123,8 @@ extern int sys_setregid(void);
 extern int sys_symlink(void);
 extern int sys_readlink(void);
 extern int sys_chmod(void);
+extern int sys_chdotuid(void);
+extern int sys_mkdir2(void);
 
 
 static int (*syscalls[])(void) = {
@@ -158,6 +160,8 @@ static int (*syscalls[])(void) = {
 [SYS_symlink]  sys_symlink,
 [SYS_readlink] sys_readlink,
 [SYS_chmod]    sys_chmod,
+[SYS_chdotuid] sys_chdotuid,
+[SYS_mkdir2]   sys_mkdir2,
 };
 
 void
diff --git a/syscall.h b/syscall.h
index cae1170..513343a 100644
--- a/syscall.h
+++ b/syscall.h
@@ -31,3 +31,5 @@
 #define SYS_symlink  30
 #define SYS_readlink 31
 #define SYS_chmod 32
+#define SYS_chdotuid 33
+#define SYS_mkdir2 34
diff --git a/sysfile.c b/sysfile.c
index 4f92589..dfd85b2 100644
--- a/sysfile.c
+++ b/sysfile.c
@@ -15,6 +15,7 @@
 #include "sleeplock.h"
 #include "file.h"
 #include "fcntl.h"
+#include "buf.h"
 
 #define LINK_LIMIT 50
 #define USER_R_BIT   1
@@ -25,18 +26,86 @@
 #define GROUP_X_BIT  6
 #define OTHER_R_BIT  7
 #define OTHER_W_BIT  8
-#define OTHER_X_BIT  9
+#define OTHER_X_BIT  9  
 
-void integer_to_binary(unsigned int in, int count, int* out)
-{
-    unsigned int mask = 1U << (count-1);
-    int i;
-    for (i = 0; i < count; i++) {
-        out[i] = (in & mask) ? 1 : 0;
-        in <<= 1;
+int isHomeThere(const char *path) {
+  const char *home = "/home/";
+
+  // Iterate through the path and look for the "/home/" substring
+  for (int i = 0; path[i] != '\0'; i++) {
+    int j;
+    for (j = 0; home[j] != '\0' && path[i + j] != '\0' && path[i + j] == home[j]; j++) {
+      // Intentionally left empty
     }
+
+    if (home[j] == '\0') {
+      return 1;
+    }
+  }
+
+  return 0;
+}
+
+
+void integer_to_binary(int n, int length, int *out) {
+  for (int i = length - 1; i >= 0; i--) {
+    out[i] = n % 2;
+    n /= 2;
+  }
 }
 
+int has_permission(struct inode *ip, int permission_bit) {
+  int bits[10];
+  integer_to_binary(ip->mode, 10, bits);
+  
+  struct proc *currproc = myproc();
+  int fileowner = ip->uid == currproc->euid;
+  int other = (fileowner != 1);
+  
+  if (fileowner) {
+    return bits[permission_bit];
+  } else if (other) {
+    return bits[permission_bit + 6];
+  }
+  
+  return 0;
+}
+
+int
+has_requested_permission(struct inode *ip, int mask)
+{
+  int mode = ip->mode;
+  // cprintf("\tip->mode=%d\n", ip->mode);
+
+  if (myproc()->uid == 0) {
+    return 1; // root user has full permissions
+  }
+
+  if (myproc()->uid == ip->uid) {
+    mask <<= 6;
+  }
+  // } else if (myproc()->gid == ip->gid) {
+  //   mask <<= 3;
+  // }
+
+  if ((mode & mask) == mask) {
+    // cprintf("mode & mask: %d\n", mode&mask);
+    return 1;
+  }
+  return 0;
+}
+
+
+// void integer_to_binary(unsigned int in, int count, int* out)
+// {
+//     unsigned int mask = 1U << (count-1);
+//     int i;
+//     for (i = 0; i < count; i++) {
+//         out[i] = (in & mask) ? 1 : 0;
+//         in <<= 1;
+//     }
+// }
+
 // Fetch the nth word-sized system call argument as a file descriptor
 // and return both the descriptor and the corresponding struct file.
 static int
@@ -286,83 +355,6 @@ bad:
   return -1;
 }
 
-// int checkWritePermission(char* path) {
-//     // If the current user can access the parent, they can access the files inside it
-//     char parent[16];
-//     struct inode* inodeParent = nameiparent(path, parent);
-
-//     // int uidParent = inodeParent->uid;
-//     // int gidParent = inodeParent->gid;
-//     int modeParent = inodeParent->mode;
-
-//     // Check the read permission bits for user, group, and others
-//     // int modeReading = 0b100100100;
-
-    
-
-//     if (myproc()->euid == 0) {
-//         // Root user can read all files
-//         return 1;
-//     } else if ((modeParent & 0200)) {
-//         // File owner has read permission
-//         return 1;
-//         // gidParent == myproc()->egid && 
-//     } else if ((modeParent & 0020)) {
-//         // Group has read permission
-//         return 1;
-//     } else if (modeParent & 0002) {
-//         // Others have read permission
-//         return 1;
-//     }
-//     return -1;
-// }
-
-// int checkReadPermission(char* path) {
-//     // If the current user can access the parent, they can access the files inside it
-//     char parent[16];
-//     struct inode* inodeParent = nameiparent(path, parent);
-
-//     int uidParent = inodeParent->uid;
-//     int modeParent = inodeParent->mode;
-
-//     // Check the read permission bits for user, group, and others
-//     // int modeReading = 0b100100100;
-
-//     if (myproc()->euid == 0) {
-//         // Root user can read all files
-//         return 1;
-//     } else if (uidParent == myproc()->euid && (modeParent & 0400)) {
-//         // File owner has read permission
-//         return 1;
-//     } else if (modeParent & 0004) {
-//         // Others have read permission
-//         return 1;
-//     }
-//     return -1;
-// }
-
-// int checkExecutePermission(char* path) {
-//     // If the current user can access the parent, they can access the files inside it
-//     char parent[16];
-//     struct inode* inodeParent = nameiparent(path, parent);
-
-//     int uidParent = inodeParent->uid;
-//     int modeParent = inodeParent->mode;
-
-  
-//     if (myproc()->euid == 0) {
-//         // Root user can execute all files
-//         return 1;
-//     } else if (uidParent == myproc()->euid && (modeParent & 0100)) {
-//         // File owner has execute permission
-//         return 1;
-//     } else if (modeParent & 0001) {
-//         // Others have execute permission
-//         return 1;
-//     }
-//     return -1;
-// }
-
 static struct inode*
 create(char *path, short type, short major, short minor, int uid, int mode)
 {
@@ -396,7 +388,7 @@ create(char *path, short type, short major, short minor, int uid, int mode)
   ip->major = major;
   ip->minor = minor;
   ip->nlink = 1;
-  ip->mode = 00644;
+  ip->mode = 0644;
   iupdate(ip);
 
   if(type == T_DIR){  // Create . and .. entries.
@@ -432,25 +424,47 @@ sys_open(void)
   //       return -1;
   //     }
   //   }
-      
-    
   //   if(omode == O_RDONLY || omode == O_RDWR){
   //     if(checkReadPermission(path)<0){
   //       return -1;
   //     }
   //   }
-    
   // }
 
-  begin_op();
+  begin_op(); 
 
+  // cprintf("omode is: %d\n", omode);
+  // int isHomeThereNum  = isHomeThere(path);
+  // cprintf("temp is: %d %s\n", isHomeThereNum, path);
   if(omode & O_CREATE){
-    ip = create(path, T_FILE, 0, 0, myproc()->uid, 00644);
+    ip = create(path, T_FILE, 0, 0, myproc()->uid, 0644);
     if(ip == 0){
       end_op();
       return -1;
     }
   } else {
+
+    ip = namei(path, 0);
+
+    cprintf("\tip->mode: %d\tip->mode & 06000: %d\tip->uid%d\n", ip->mode, (ip->mode & 06000), ip->uid);
+
+    if ((ip->uid != myproc()->euid) || !(ip->mode & 06000)){
+      
+    }
+
+    // // Check for read and write permissions
+    // int mask = 0;
+    // if (omode & O_RDONLY || omode & O_RDWR) {
+    //   mask |= 0400;
+    // }
+    // if (omode & O_WRONLY || omode & O_RDWR) {
+    //   mask |= 0200;
+    // }
+    // if (!has_requested_permission(ip, mask)) {
+    //   return -1; // Permission denied
+    // }
+
+
     if((ip = namei(path,1)) == 0){
       end_op();
       return -1;
@@ -489,52 +503,23 @@ sys_open(void)
     
     }
 
-    int bits[10];
-        integer_to_binary(ip -> mode, 10, bits);
-
-        struct proc *currproc = myproc();
-        int fileowner = ip -> uid == currproc -> euid;
-        int other = (fileowner != 1);
-        int invalid = 0;
-        
-        if (omode == O_RDWR) {
-                if (fileowner) {
-                        if (!bits[USER_R_BIT] || !bits[USER_W_BIT])
-                                invalid = 1;
-                } 
-                else if (other) {
-                        if (!bits[OTHER_R_BIT])
-                                invalid = 1;
-                }
-        } else if (omode == O_RDONLY) {
-                if (fileowner) {
-                        if (!bits[USER_R_BIT])
-                                invalid = 1;
-                } 
-                else if (other) {
-                        if (!bits[OTHER_R_BIT])
-                                invalid = 1;
-                }
-        } else if (omode == O_WRONLY) {
-                if (fileowner) {
-                        if (!bits[USER_W_BIT])
-                                invalid = 1;
-                }
-                else if (other) {
-                        if (!bits[OTHER_W_BIT])
-                                invalid = 1;
-                }
-	}
-
-        // If we're root, invalid is not important
-        invalid = currproc -> euid == 0 ? 0 : invalid;
-
-        if (invalid) {
-                cprintf("%s: Permission denied\n", path);
-                iunlockput(ip);
-                end_op();
-                return -1;
-        }
+    // if (ip->type == T_DIR && omode != O_RDONLY) {
+    // iunlockput(ip);
+    // end_op();
+    // return -1;
+    // }  
+    // if (!has_permission(ip, USER_R_BIT) && (omode == O_RDONLY || omode == O_RDWR)) {
+    //   cprintf("%s: Permission denied\n", path);
+    //   iunlockput(ip);
+    //   end_op();
+    //   return -1;
+    // }
+    // if (!has_permission(ip, USER_W_BIT) && (omode == O_WRONLY || omode == O_RDWR)) {
+    //   cprintf("%s: Permission denied\n", path);
+    //   iunlockput(ip);
+    //   end_op();
+    //   return -1;
+    // }
 
   
     
@@ -659,13 +644,6 @@ sys_chdir(void)
 
   
 
-  
-  // if(checkExecutePermission(path)<0){
-  //   end_op();
-  //   cprintf("My function failed\n");
-  //   return -1;
-  // }
-  
   ilock(ip);
   if(ip->type != T_DIR){
     iunlockput(ip);
@@ -675,11 +653,10 @@ sys_chdir(void)
 
   int bits[10];
 	integer_to_binary(ip -> mode, 10, bits);
-	int hasperm = 0;
 
 	int fileowner = ip -> uid == curproc -> euid;
 	int other = fileowner != 1;
-  cprintf("Fileowner, other: %d, %d\n", fileowner, other);
+  //cprintf("Fileowner, other: %d, %d\n", fileowner, other);
 	int invalid = 0;
 	if (fileowner) {
 		if (ip->mode && 0100)
@@ -719,6 +696,21 @@ sys_exec(void)
     return -1;
   }
   memset(argv, 0, sizeof(argv));
+
+  // struct inode *ip;
+  // if ((ip = namei(path,1)) == 0) {
+  //   return -1;
+  // }
+  
+  // ilock(ip);
+  // if (!has_permission(ip, USER_X_BIT)) {
+  //   cprintf("%s: Permission denied Execute\n", path);
+  //   iunlockput(ip);
+  //   return -1;
+  // }
+  // iunlock(ip);
+
+
   for(i=0;; i++){
     if(i >= NELEM(argv))
       return -1;
@@ -951,3 +943,80 @@ sys_seteuid(void)
 
   return -1;
 }
+
+int
+chdotuid(int inum, int uid)
+{
+  struct inode *ip;
+  struct dirent de;
+  struct inode *dot_inode;
+
+  begin_op();
+  ip = get_inode_by_num(ROOTDEV, inum);
+
+  if(ip == 0){
+    end_op();
+    return -1;
+  }
+
+  ilock(ip);
+
+  if(ip->type != T_DIR){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  if(readi(ip, (char*)&de, 0, sizeof(de)) != sizeof(de)){
+    iunlockput(ip);
+    end_op();
+    return -1;
+  }
+
+  dot_inode = get_inode_by_num(ROOTDEV, de.inum);
+  ilock(dot_inode);
+
+  dot_inode->uid = uid;
+  iupdate(dot_inode);
+
+  iunlockput(ip);
+  iunlockput(dot_inode);
+  end_op();
+
+  return 0;
+}
+
+int
+sys_chdotuid(void)
+{
+  int inum;
+  int uid;
+
+  if(argint(0, &inum) < 0 || argint(1, &uid) < 0)
+    return -1;
+
+  return chdotuid(inum, uid);
+}
+
+int sys_mkdir2(void)
+{
+  char *path;
+  struct inode *ip;
+  int uid;
+
+  begin_op();
+
+  if (argstr(1, &uid) <0){
+    end_op();
+    return -1;
+  }
+  cprintf("uid is: %d\n", uid);
+  if(argstr(0, &path) < 0 || (ip = create(path, T_DIR, 0, 0, uid, 00644)) == 0){
+    // panic("error here");
+    end_op();
+    return -1;
+  }
+  iunlockput(ip);
+  end_op();
+  return 0;
+}
diff --git a/user.h b/user.h
index c44f34e..970b6ab 100644
--- a/user.h
+++ b/user.h
@@ -38,6 +38,9 @@ int setregid(int rgid, int egid);
 int symlink(const char*, const char*);
 int readlink(const char*, char*, size_t);
 int chmod(const char*, int mode);
+int chdotuid(int inum, int uid);
+int mkdir2(const char*, int uid);
+
 // ulib.c
 int stat(const char*, struct stat*);
 char* strcpy(char*, const char*);
diff --git a/usys.S b/usys.S
index a62f1c8..a20f832 100644
--- a/usys.S
+++ b/usys.S
@@ -40,3 +40,5 @@ SYSCALL(setregid)
 SYSCALL(symlink)
 SYSCALL(readlink)
 SYSCALL(chmod)
+SYSCALL(chdotuid)
+SYSCALL(mkdir2)
